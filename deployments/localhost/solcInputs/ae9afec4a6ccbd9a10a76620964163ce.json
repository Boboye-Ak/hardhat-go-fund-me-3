{
  "language": "Solidity",
  "sources": {
    "contracts/Cause.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\ncontract Cause {\r\n    //State Variables\r\n    uint256 public s_causeBalance;\r\n    uint256 public immutable i_goal;\r\n    uint256 public immutable i_percentCut;\r\n    uint256 public immutable i_causeId;\r\n    bool public s_isGoalReached;\r\n    bool public s_isOpenToDonations;\r\n    bool public s_isBlocked;\r\n    bool public s_isWithdrawn;\r\n    address public s_causeOwner;\r\n    address public s_causeCreatorContract;\r\n    string public s_causeName;\r\n    string public s_causeURI;\r\n    mapping(address => uint256) public donorToAmountDonated;\r\n    address[] public donorList;\r\n\r\n    //Custom Errors\r\n    error Cause__IsNotOpenToDonations();\r\n    error Cause__GoalAlreadyReached();\r\n    error Cause__OnlyCauseOwnerCanCall();\r\n    error Cause__ErrorWithdrawing();\r\n    error Cause__CannotOpenToDonationsAfterWithdrawal();\r\n    error Cause__IsBlocked();\r\n    error Cause__IsBlockedAlready();\r\n    error Cause__IsUnblockedAlready();\r\n    error Cause__OnlyCreatorContractCanCall();\r\n    error Cause__CauseOwnerHasWithdrawnAlready();\r\n    error Cause__YouDoNotHaveAnyDonationToThisCause();\r\n\r\n    //Events\r\n    event DonationMade(address indexed donor, uint256 amount);\r\n    event WithdrawalMade(address indexed withdrawer, uint256 amount);\r\n    event IsOpenToDonationsSwitched(bool isOpenToDonations);\r\n    event OwnershipChanged(address indexed newOwner);\r\n    event CauseURISet(string causeURI);\r\n    event CauseLocked(bool isLocked);\r\n    event CauseUnlocked(bool isLocked);\r\n    event Refunded(address refundee, uint256 amount);\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender != s_causeOwner) {\r\n            revert Cause__OnlyCauseOwnerCanCall();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyParentContract() {\r\n        if (msg.sender != s_causeCreatorContract) {\r\n            revert Cause__OnlyCreatorContractCanCall();\r\n        }\r\n        _;\r\n    }\r\n\r\n    //Constructor\r\n    constructor(\r\n        string memory causeName,\r\n        uint256 goal,\r\n        address payable causeOwner,\r\n        uint256 percentCut,\r\n        uint256 causeId\r\n    ) {\r\n        s_causeCreatorContract = msg.sender;\r\n        s_causeName = causeName;\r\n        s_causeOwner = causeOwner;\r\n        i_goal = goal;\r\n        s_isOpenToDonations = true;\r\n        i_percentCut = percentCut;\r\n        i_causeId = causeId;\r\n        s_isBlocked = true;\r\n    }\r\n\r\n    //Receive and Fallback Functions\r\n    receive() external payable {\r\n        donate();\r\n    }\r\n\r\n    fallback() external payable {\r\n        donate();\r\n    }\r\n\r\n    //PURE FUNCTIONS\r\n    //Donate Function\r\n    function donate() public payable {\r\n        if (s_isGoalReached) {\r\n            revert Cause__GoalAlreadyReached();\r\n        }\r\n        if (!s_isOpenToDonations) {\r\n            revert Cause__IsNotOpenToDonations();\r\n        }\r\n        if (s_isBlocked) {\r\n            revert Cause__IsBlocked();\r\n        }\r\n\r\n        s_causeBalance += msg.value;\r\n        donorList.push(msg.sender);\r\n        donorToAmountDonated[msg.sender] += msg.value;\r\n        if (s_causeBalance >= i_goal) {\r\n            s_isGoalReached = true;\r\n            s_isOpenToDonations = false;\r\n        }\r\n        emit DonationMade(msg.sender, msg.value);\r\n    }\r\n\r\n    //Withdraw Function\r\n    function withdraw() public onlyOwner {\r\n        if (s_isBlocked) {\r\n            revert Cause__IsBlocked();\r\n        }\r\n        uint256 amount = address(this).balance;\r\n        uint256 parentContractCut = ((amount * i_percentCut) / 10000);\r\n        bool paymentToParentSuccess = payable(s_causeCreatorContract).send(parentContractCut);\r\n        if (!paymentToParentSuccess) {\r\n            revert Cause__ErrorWithdrawing();\r\n        }\r\n        bool withdrawalSuccess = payable(msg.sender).send(address(this).balance);\r\n        if (!withdrawalSuccess) {\r\n            revert Cause__ErrorWithdrawing();\r\n        } else {\r\n            s_isOpenToDonations = false;\r\n            s_causeBalance = 0;\r\n            s_isWithdrawn = true;\r\n            emit WithdrawalMade(msg.sender, amount);\r\n        }\r\n    }\r\n\r\n    function changeOwnership(address payable newOwner) public onlyOwner {\r\n        if (s_isBlocked) {\r\n            revert Cause__IsBlocked();\r\n        }\r\n        s_causeOwner = newOwner;\r\n        emit OwnershipChanged(newOwner);\r\n    }\r\n\r\n    function switchIsOpenToDonations() public onlyOwner {\r\n        if (s_isOpenToDonations) {\r\n            s_isOpenToDonations = false;\r\n        } else {\r\n            if (s_isWithdrawn) {\r\n                revert Cause__CannotOpenToDonationsAfterWithdrawal();\r\n            } else {\r\n                s_isOpenToDonations = true;\r\n            }\r\n        }\r\n        emit IsOpenToDonationsSwitched(s_isOpenToDonations);\r\n    }\r\n\r\n    function setCauseURI(\r\n        string memory causeURI /* Will be the URI of an IPFS Json file  */\r\n    ) public onlyOwner {\r\n        if (s_isBlocked) {\r\n            revert Cause__IsBlocked();\r\n        }\r\n        s_causeURI = causeURI;\r\n        emit CauseURISet(s_causeURI);\r\n    }\r\n\r\n    function lock() public onlyParentContract {\r\n        if (s_isBlocked) {\r\n            revert Cause__IsBlockedAlready();\r\n        }\r\n        s_isBlocked = true;\r\n        emit CauseLocked(s_isBlocked);\r\n    }\r\n\r\n    function unlock() public onlyParentContract {\r\n        if (!s_isBlocked) {\r\n            revert Cause__IsUnblockedAlready();\r\n        }\r\n        s_isBlocked = false;\r\n        emit CauseUnlocked(s_isBlocked);\r\n    }\r\n\r\n    function demandRefund() public payable {\r\n        if (s_isWithdrawn) {\r\n            revert Cause__CauseOwnerHasWithdrawnAlready();\r\n        }\r\n        if (donorToAmountDonated[msg.sender] == 0) {\r\n            revert Cause__YouDoNotHaveAnyDonationToThisCause();\r\n        }\r\n        uint256 amount = donorToAmountDonated[msg.sender];\r\n        bool success = payable(msg.sender).send(amount);\r\n        if (!success) {\r\n            revert Cause__ErrorWithdrawing();\r\n        }\r\n        donorToAmountDonated[msg.sender] = 0;\r\n        s_causeBalance = s_causeBalance - amount;\r\n        if (s_causeBalance < i_goal) {\r\n            s_isGoalReached = false;\r\n            if (!s_isWithdrawn && !s_isBlocked) {\r\n                s_isOpenToDonations = true;\r\n            }\r\n        }\r\n\r\n        emit Refunded(msg.sender, amount);\r\n    }\r\n\r\n    //VIEW FUNCTIONS\r\n    function getCauseBalance() public view returns (uint256) {\r\n        return s_causeBalance;\r\n    }\r\n\r\n    function getGoal() public view returns (uint256) {\r\n        return i_goal;\r\n    }\r\n\r\n    function getCauseName() public view returns (string memory) {\r\n        return s_causeName;\r\n    }\r\n\r\n    function getCauseOwner() public view returns (address) {\r\n        return s_causeOwner;\r\n    }\r\n\r\n    function getIsGoalReached() public view returns (bool) {\r\n        return s_isGoalReached;\r\n    }\r\n\r\n    function getIsOpenToDonations() public view returns (bool) {\r\n        return s_isOpenToDonations;\r\n    }\r\n\r\n    function getCauseURI() public view returns (string memory) {\r\n        return s_causeURI;\r\n    }\r\n\r\n    function getIsWithdrawn() public view returns (bool) {\r\n        return s_isWithdrawn;\r\n    }\r\n\r\n    function getIsLocked() public view returns (bool) {\r\n        return s_isBlocked;\r\n    }\r\n\r\n    function getMyDonation() public view returns (uint256) {\r\n        uint256 donationAmount = donorToAmountDonated[msg.sender];\r\n        return donationAmount;\r\n    }\r\n}\r\n"
    },
    "contracts/CrowdFunder.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\nimport \"./Cause.sol\";\r\n\r\ncontract CrowdFunder {\r\n    //STATE VARIABLES\r\n    address payable public immutable i_crowdFunderOwner;\r\n    mapping(address => address) public walletToCauseOwned;\r\n    mapping(address => uint256) public hasCause;\r\n    mapping(address => uint256) public causeToId;\r\n    uint256 public immutable i_percentCut;\r\n    uint256 public s_nextCauseId;\r\n    Cause[] public s_causes;\r\n\r\n    //CUSTOM ERRORS\r\n    error CrowdFunder__OnlyOwnerCanCallThis();\r\n    error CrowdFunder__ThisWalletAlreadyHasACause();\r\n    error CrowdFunder__ErrorWithdrawing();\r\n\r\n    //EVENTS\r\n    event CauseCreated(address indexed causeAddress);\r\n    event DonationReceived(uint256 indexed amount);\r\n    event WithdrawalMade(uint256 indexed amount);\r\n\r\n    //MODIFIERS\r\n    modifier onlyOwner() {\r\n        if (msg.sender != i_crowdFunderOwner) {\r\n            revert CrowdFunder__OnlyOwnerCanCallThis();\r\n        }\r\n        _;\r\n    }\r\n\r\n    //CONSTRUCTOR\r\n    constructor(\r\n        uint256 percentCut /*Percentage given in Basis Points ie 100 basis points=1% */\r\n    ) {\r\n        i_crowdFunderOwner = payable(msg.sender);\r\n        i_percentCut = percentCut;\r\n        s_nextCauseId = 1;\r\n    }\r\n\r\n    //RECEIVE AND FALLBACK FUNCTIONS\r\n    receive() external payable {\r\n        emit DonationReceived(msg.value);\r\n    }\r\n\r\n    fallback() external payable {\r\n        emit DonationReceived(msg.value);\r\n    }\r\n\r\n    //PURE FUNCTIONS\r\n    //Create Cause Function\r\n    function createCause(string memory causeName, uint256 goal) public returns (address) {\r\n        if (hasCause[msg.sender] != 0) {\r\n            revert CrowdFunder__ThisWalletAlreadyHasACause();\r\n        }\r\n        Cause newCause = new Cause(\r\n            causeName,\r\n            goal,\r\n            payable(msg.sender),\r\n            i_percentCut,\r\n            s_nextCauseId\r\n        );\r\n        newCause.unlock();\r\n        s_causes.push(newCause);\r\n        walletToCauseOwned[msg.sender] = address(newCause);\r\n        hasCause[msg.sender] = s_nextCauseId;\r\n        causeToId[address(newCause)] = s_nextCauseId;\r\n        s_nextCauseId = s_nextCauseId + 1;\r\n        emit CauseCreated(address(newCause));\r\n        return address(newCause);\r\n    }\r\n\r\n    function sponsorSite() public payable {\r\n        emit DonationReceived(msg.value);\r\n    }\r\n\r\n    //Withdraw Function\r\n    function withdraw() public payable onlyOwner {\r\n        uint256 amount = address(this).balance;\r\n        bool success = payable(msg.sender).send(amount);\r\n        if (!success) {\r\n            revert CrowdFunder__ErrorWithdrawing();\r\n        }\r\n    }\r\n\r\n    //Block Cause Function\r\n    function lock(uint256 causeId) public onlyOwner {\r\n        Cause cause = s_causes[causeId - 1];\r\n        cause.lock();\r\n    }\r\n\r\n    function unlock(uint256 causeId) public onlyOwner {\r\n        Cause cause = s_causes[causeId - 1];\r\n        cause.unlock();\r\n    }\r\n\r\n    //VIEW FUNCTIONS\r\n    function getCauseById(uint256 causeId) public view returns (address) {\r\n        address causeAddress = address(s_causes[causeId - 1]);\r\n        return causeAddress;\r\n    }\r\n\r\n    function getCauseAddressByOwnerWallet(address owner) public view returns (address) {\r\n        address causeAddress = walletToCauseOwned[owner];\r\n        return causeAddress;\r\n    }\r\n\r\n    function getCauseIdByOwnerAddress(address owner) public view returns (uint256) {\r\n        uint256 causeId = hasCause[owner];\r\n        return causeId;\r\n    }\r\n\r\n    function getCauseIdByCauseAddress(address causeAddress) public view returns (uint256) {\r\n        uint256 causeId = causeToId[causeAddress];\r\n        return causeId;\r\n    }\r\n\r\n    function getMyCauseId() public view returns (uint256) {\r\n        uint256 causeId = hasCause[msg.sender];\r\n        return (causeId);\r\n    }\r\n\r\n    function getLatestCauseAddress() public view returns (address) {\r\n        address latestCauseAddress = address(s_causes[s_nextCauseId - 2]);\r\n        return latestCauseAddress;\r\n    }\r\n\r\n    function getContractBalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function getContractOwner() public view returns (address) {\r\n        return i_crowdFunderOwner;\r\n    }\r\n\r\n    function getPercentCut() public view returns (uint256) {\r\n        return i_percentCut;\r\n    }\r\n\r\n    function confirmCause(address causeToCheck) public view returns (bool) {\r\n        /*Returns true if the Cause is truly deployed by this contract */\r\n        if (causeToId[causeToCheck] != 0) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}